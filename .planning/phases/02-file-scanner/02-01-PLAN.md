---
phase: 02-file-scanner
plan: 01
type: execute
---

<objective>
Create the FileScanner actor that walks directories, applies skip rules, respects depth limits, and discovers files matching known Claude config extensions.

Purpose: Core file discovery engine — the foundation of the scanner that Phase 2 plans 02 and 03 build upon.
Output: FileScanner actor in Services/ that can enumerate files across all scan locations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

@ClaudeShelf/Models/ScanLocation.swift
@ClaudeShelf/Models/FileEntry.swift
@ClaudeShelf/Models/ScanResult.swift

**Tech available:** SwiftUI, Swift 6, CryptoKit, Observation framework
**Established patterns:** @Observable + @MainActor for state, value types as Sendable
**Key constraint:** Must use FileManager for all filesystem access. No third-party deps. Actor isolation for thread safety.

**Scanner requirements from PROJECT.md:**
- Scan locations: ~/.claude/, ~/projects/, ~/src/, ~/dev/, ~/code/, ~/workspace/, ~/repos/, ~/
- Skip dirs: .git, node_modules, .venv, __pycache__, hidden dirs (except .claude)
- Depth limit: max 2 levels for non-.claude directories
- Known extensions: .md, .json, .yaml, .yml, .txt, .toml, .log, .sh
- Special files: CLAUDE.md and .clauderc recognized anywhere
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileScanner actor with directory walking</name>
  <files>
    ClaudeShelf/Services/FileScanner.swift,
    ClaudeShelf.xcodeproj/project.pbxproj
  </files>
  <action>
    Create `ClaudeShelf/Services/FileScanner.swift` with a Swift actor:

    ```
    actor FileScanner {
        // Known Claude config file extensions
        static let knownExtensions: Set<String> = ["md", "json", "yaml", "yml", "txt", "toml", "log", "sh"]

        // Special filenames recognized anywhere (not just inside .claude/)
        static let specialFiles: Set<String> = ["CLAUDE.md", ".clauderc"]

        // Directories to skip during scanning
        static let skipDirectories: Set<String> = [".git", "node_modules", ".venv", "__pycache__"]

        // Max depth for non-.claude directories (0 = scan location itself, 1 = immediate children, 2 = grandchildren)
        static let maxDepth = 2
    }
    ```

    Add a method `scanLocations(_ locations: [ScanLocation]) async -> ScanResult` that:

    1. Iterates enabled locations from the `locations` array
    2. Expands `~` to the user's home directory using `FileManager.default.homeDirectoryForCurrentUser`
    3. For each location, calls `scanDirectory(at:currentDepth:isInsideClaude:)`
    4. Collects all discovered file URLs
    5. Returns a ScanResult with timing info

    Add a private method `scanDirectory(at url: URL, currentDepth: Int, isInsideClaude: Bool) -> [DiscoveredFile]` that:

    1. Uses `FileManager.default.contentsOfDirectory(at:includingPropertiesForKeys:options:)` with keys: `.isDirectoryKey`, `.fileSizeKey`, `.contentModificationDateKey`, `.isWritableKey`
    2. For each item:
       - If directory:
         - Skip if name is in `skipDirectories`
         - Skip if name starts with "." AND name is NOT ".claude" (skip hidden dirs except .claude)
         - If name is ".claude", recurse with `isInsideClaude: true` and NO depth limit
         - Otherwise, recurse only if `currentDepth < maxDepth` and NOT `isInsideClaude`
       - If file:
         - If `isInsideClaude` and file extension is in `knownExtensions` → include
         - If file name is in `specialFiles` → include (CLAUDE.md and .clauderc anywhere)
         - Otherwise → skip
    3. Handle errors gracefully — log with `os.Logger` at `.error` level, don't crash. Collect error messages into the errors array.

    Create a helper struct (internal to the file, not a separate file):
    ```
    struct DiscoveredFile: Sendable {
        let url: URL
        let name: String
        let size: Int64
        let modifiedDate: Date
        let isReadOnly: Bool
        let isInsideClaude: Bool
        let claudeRelativePath: String?  // path relative to .claude/ dir, for category assignment
    }
    ```

    Import `os` for logging. Create a static logger: `private static let logger = Logger(subsystem: "com.claudeshelf.app", category: "FileScanner")`

    Add the file to project.pbxproj: PBXFileReference, PBXBuildFile, add to Services PBXGroup (A1B2C3D4E5F6A1B2C3D45005), add to app target source build phase (A1B2C3D4E5F6A1B2C3D46001). Use C1... prefix for new IDs.
  </action>
  <verify>
    Run: `xcodebuild -project ClaudeShelf.xcodeproj -scheme ClaudeShelf -configuration Debug build 2>&1 | tail -5`
    Should show BUILD SUCCEEDED with no warnings.
  </verify>
  <done>
    FileScanner actor exists, compiles without errors or concurrency warnings under Swift 6 strict mode, has scanLocations and scanDirectory methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PathDecoder utility for project name extraction</name>
  <files>
    ClaudeShelf/Utilities/PathDecoder.swift,
    ClaudeShelf.xcodeproj/project.pbxproj
  </files>
  <action>
    Create `ClaudeShelf/Utilities/PathDecoder.swift`:

    Claude encodes project paths as directory names under `~/.claude/projects/`. For example:
    - `~/.claude/projects/-home-user-Projects-MyApp/` → project name is "MyApp"
    - `~/.claude/projects/-Users-kevin-code-my-tool/` → project name is "my-tool"

    The decoder must:

    1. **`decodeProjectName(from encodedPath: String) -> String?`** (static method)
       - Takes an encoded directory name (e.g., "-home-user-Projects-MyApp")
       - Splits on "-" (the separator Claude uses)
       - Strips common path prefixes: "home", "Users", "user", "Documents", "Desktop", "Projects", "projects", "src", "dev", "code", "workspace", "repos", "Github", "github", "Repos"
       - Strips single-character segments (drive letters on Windows paths: "C", "D", etc.)
       - Returns the last remaining meaningful segment as the project name
       - Returns nil if no meaningful name can be extracted

    2. **`detectScope(for path: String, homeDirectory: String) -> (scope: Scope, project: String?)`** (static method)
       - If path starts with `homeDirectory/.claude/projects/` → scope is `.project`, extract project name from the encoded dir
       - If path starts with `homeDirectory/.claude/` (but not projects/) → scope is `.global`, project is nil
       - If path contains `/.claude/` elsewhere → scope is `.project`, extract project name from parent of .claude
       - If file is CLAUDE.md not inside .claude → scope is `.project`, extract project from parent dir name
       - Otherwise → scope is `.global`, project is nil

    3. **`displayName(for file: String, project: String?) -> String`** (static method)
       - If project exists: return "\(project)/\(file)"
       - Otherwise: return file name only

    Make all methods static on a `struct PathDecoder` (no stored state needed). Struct is automatically Sendable.

    Add to project.pbxproj under Utilities group (A1B2C3D4E5F6A1B2C3D45009).
  </action>
  <verify>
    Run: `xcodebuild -project ClaudeShelf.xcodeproj -scheme ClaudeShelf -configuration Debug build 2>&1 | tail -5`
    Should show BUILD SUCCEEDED.
  </verify>
  <done>
    PathDecoder exists with decodeProjectName, detectScope, and displayName methods. Compiles cleanly under Swift 6 strict concurrency.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodebuild build` succeeds with no errors
- [ ] FileScanner actor compiles with no concurrency warnings
- [ ] PathDecoder compiles as Sendable struct
- [ ] FileScanner handles skip directories correctly (skips .git, node_modules, etc.)
- [ ] FileScanner handles depth limiting (max 2 for non-.claude)
- [ ] FileScanner allows unlimited depth inside .claude/ directories
</verification>

<success_criteria>

- FileScanner actor exists in Services/ with directory walking logic
- PathDecoder exists in Utilities/ with project name decoding
- Both compile clean under Swift 6 strict concurrency
- Skip rules, depth limits, and extension filtering implemented
- Ready for Plan 02-02 (category assignment) to consume DiscoveredFile
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-scanner/02-01-SUMMARY.md`
</output>
