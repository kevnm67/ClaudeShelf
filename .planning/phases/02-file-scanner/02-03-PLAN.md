---
phase: 02-file-scanner
plan: 03
type: execute
---

<objective>
Wire the FileScanner into AppState for async scanning on app launch, add error handling with user-friendly messages, and create unit tests for scanner, category assignment, and path decoding.

Purpose: Make the scanner functional end-to-end — app launches, scans, and populates the file list. Tests verify correctness of the ported Go logic.
Output: Working scan-on-launch flow and comprehensive unit tests. Phase 2 complete.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-file-scanner/02-01-SUMMARY.md
@.planning/phases/02-file-scanner/02-02-SUMMARY.md

@ClaudeShelf/App/AppState.swift
@ClaudeShelf/App/ClaudeShelfApp.swift
@ClaudeShelf/Services/FileScanner.swift
@ClaudeShelf/Services/CategoryAssigner.swift
@ClaudeShelf/Utilities/PathDecoder.swift
@ClaudeShelf/Models/FileEntry.swift
@ClaudeShelf/Models/ScanResult.swift

**Established patterns:**
- @Observable + @MainActor for AppState
- Actor isolation for FileScanner
- os.Logger for internal logging
- User-friendly error messages in UI (never expose raw paths/system errors)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire FileScanner into AppState with async scan on launch</name>
  <files>
    ClaudeShelf/App/AppState.swift,
    ClaudeShelf/App/ClaudeShelfApp.swift,
    ClaudeShelf/App/ContentView.swift
  </files>
  <action>
    1. **Add scan method to AppState:**

    ```swift
    @Observable
    @MainActor
    final class AppState {
        // ... existing properties ...

        private let scanner = FileScanner()

        /// Performs a full scan of all enabled locations.
        func performScan() async {
            guard !isScanning else { return }  // Prevent concurrent scans
            isScanning = true
            errorMessage = nil

            let result = await scanner.scan(locations: scanLocations)

            files = result.files
            lastScanDate = result.scanDate
            isScanning = false

            if !result.errors.isEmpty {
                // Show user-friendly message, don't expose raw paths
                errorMessage = "Some locations could not be scanned. \(result.errors.count) error(s) occurred."
            }
        }
    }
    ```

    Note: `FileScanner` is an actor, so calling `scanner.scan(locations:)` from `@MainActor` context requires `await` — this is correct and will run the scan off the main thread.

    2. **Trigger scan on app launch in ClaudeShelfApp.swift:**

    Add a `.task` modifier to ContentView in the WindowGroup:

    ```swift
    WindowGroup {
        ContentView()
            .environment(appState)
            .task {
                await appState.performScan()
            }
    }
    ```

    3. **Update ContentView to show scan status:**

    Update the detail pane to show scanning indicator:

    ```swift
    var body: some View {
        NavigationSplitView {
            Text("Categories")
                .navigationTitle("ClaudeShelf")
        } content: {
            if appState.isScanning {
                ProgressView("Scanning...")
            } else {
                Text("\(appState.filteredFiles.count) files found")
            }
        } detail: {
            if let errorMessage = appState.errorMessage {
                Text(errorMessage)
                    .foregroundStyle(.red)
            } else {
                Text("Select a file to edit")
                    .foregroundStyle(.secondary)
            }
        }
        .frame(minWidth: 800, minHeight: 500)
    }
    ```

    Do NOT add `@Bindable` — we only read from AppState in ContentView. Binding is needed only when mutating state from the view.
  </action>
  <verify>
    Run: `xcodebuild -project ClaudeShelf.xcodeproj -scheme ClaudeShelf -configuration Debug build 2>&1 | tail -5`
    Should show BUILD SUCCEEDED. No concurrency warnings.
  </verify>
  <done>
    App launches, triggers scan via .task modifier, FileScanner runs on its own actor, results populate AppState.files on main actor. Scanning indicator shown during scan.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for scanner components</name>
  <files>
    ClaudeShelfTests/CategoryAssignerTests.swift,
    ClaudeShelfTests/PathDecoderTests.swift,
    ClaudeShelfTests/FileEntryTests.swift,
    ClaudeShelf.xcodeproj/project.pbxproj
  </files>
  <action>
    Create 3 test files in ClaudeShelfTests/ and add them to the test target's source build phase (A1B2C3D4E5F6A1B2C3D46002).

    1. **CategoryAssignerTests.swift** — Test all 12 rules:

    ```swift
    import XCTest
    @testable import ClaudeShelf

    final class CategoryAssignerTests: XCTestCase {
        // Rule 1: /agents/ + .md → Agents
        func testAgentsMdFile() {
            let cat = CategoryAssigner.assignCategory(fileName: "my-agent.md", path: "/home/.claude/agents/my-agent.md", isInsideClaude: true)
            XCTAssertEqual(cat, .agents)
        }

        // Rule 1 negative: /agents/ + .json → NOT Agents (falls through)
        func testAgentsNonMdFile() {
            let cat = CategoryAssigner.assignCategory(fileName: "config.json", path: "/home/.claude/agents/config.json", isInsideClaude: true)
            XCTAssertNotEqual(cat, .agents)
        }

        // Rule 2: /debug/ → Debug
        func testDebugFile() { ... }

        // Rule 3: /memory/ → Memory
        func testMemoryDir() { ... }

        // Rule 3: memory.md → Memory
        func testMemoryMdFile() { ... }

        // Rule 4: CLAUDE.md outside .claude → Project Config
        func testClaudeMdOutside() { ... }

        // Rule 5: settings.json → Settings
        func testSettingsJson() { ... }

        // Rule 5: .clauderc → Settings
        func testClauderc() { ... }

        // Rule 6: .sh inside .claude → Settings
        func testShellScript() { ... }

        // Rule 6 negative: .sh in shell-snapshots → NOT Settings
        func testShellSnapshot() { ... }

        // Rule 7: stats-cache.json → Settings
        func testStatsCache() { ... }

        // Rule 8: /todos/ → Todos
        func testTodos() { ... }

        // Rule 8: /tasks/ → Todos
        func testTasks() { ... }

        // Rule 9: /plans/ → Plans
        func testPlans() { ... }

        // Rule 10: /skills/ → Skills
        func testSkills() { ... }

        // Rule 11: CLAUDE.md inside .claude → Project Config
        func testClaudeMdInside() { ... }

        // Rule 12: other → Other
        func testOther() { ... }

        // Priority: agents rule beats plans rule
        func testPriorityAgentsOverPlans() {
            let cat = CategoryAssigner.assignCategory(fileName: "agent.md", path: "/home/.claude/plans/agents/agent.md", isInsideClaude: true)
            XCTAssertEqual(cat, .agents)
        }
    }
    ```

    Implement ALL test methods fully (not just stubs). Each test should call `CategoryAssigner.assignCategory` with specific inputs and assert the expected Category output.

    2. **PathDecoderTests.swift** — Test project name decoding:

    ```swift
    func testBasicProjectDecode() {
        let name = PathDecoder.decodeProjectName(from: "-home-user-Projects-MyApp")
        XCTAssertEqual(name, "MyApp")
    }

    func testUsersPath() {
        let name = PathDecoder.decodeProjectName(from: "-Users-kevin-code-my-tool")
        XCTAssertEqual(name, "my-tool")
    }

    func testSingleSegment() {
        let name = PathDecoder.decodeProjectName(from: "-home-user-Projects")
        XCTAssertEqual(name, "Projects")  // Last segment after stripping
    }

    func testScopeDetection() {
        let (scope, project) = PathDecoder.detectScope(
            for: "/Users/kevin/.claude/projects/-Users-kevin-code-MyApp/settings.json",
            homeDirectory: "/Users/kevin"
        )
        XCTAssertEqual(scope, .project)
        XCTAssertEqual(project, "MyApp")
    }

    func testGlobalScope() {
        let (scope, project) = PathDecoder.detectScope(
            for: "/Users/kevin/.claude/settings.json",
            homeDirectory: "/Users/kevin"
        )
        XCTAssertEqual(scope, .global)
        XCTAssertNil(project)
    }
    ```

    3. **FileEntryTests.swift** — Test ID generation:

    ```swift
    func testIDGeneration() {
        let id = FileEntry.generateID(from: "/Users/kevin/.claude/settings.json")
        XCTAssertEqual(id.count, 16)  // 8 bytes = 16 hex chars
    }

    func testIDConsistency() {
        let id1 = FileEntry.generateID(from: "/some/path")
        let id2 = FileEntry.generateID(from: "/some/path")
        XCTAssertEqual(id1, id2)  // Same path = same ID
    }

    func testIDUniqueness() {
        let id1 = FileEntry.generateID(from: "/path/a")
        let id2 = FileEntry.generateID(from: "/path/b")
        XCTAssertNotEqual(id1, id2)  // Different paths = different IDs
    }
    ```

    Add all 3 test files to the ClaudeShelfTests target in project.pbxproj.
  </action>
  <verify>
    Run: `xcodebuild -project ClaudeShelf.xcodeproj -scheme ClaudeShelf -destination 'platform=macOS' test 2>&1 | grep -E "(Test Suite|Test Case|Executed|FAILED|BUILD)" | tail -20`
    All tests should pass.
  </verify>
  <done>
    All unit tests pass. CategoryAssigner tested for all 12 rules + priority ordering. PathDecoder tested for project name extraction and scope detection. FileEntry ID generation tested for length, consistency, uniqueness. Phase 2 complete.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodebuild build` succeeds
- [ ] `xcodebuild test` passes all tests
- [ ] App launches and triggers scan automatically
- [ ] Scanning indicator visible during scan
- [ ] Files populate after scan completes
- [ ] All 12 category rules tested
- [ ] Path decoding tested with multiple formats
- [ ] No concurrency warnings under Swift 6 strict mode
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- App scans on launch and shows file count
- Unit tests cover all critical scanner logic
- No errors or warnings introduced
- Phase 2 File Scanner complete — ready for Phase 3 (Core UI)
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-scanner/02-03-SUMMARY.md`
</output>
