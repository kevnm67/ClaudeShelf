---
phase: 01-foundation
plan: 02
type: execute
---

<objective>
Create all core data models and the AppState observable that the rest of the app depends on.

Purpose: Define the data types that every subsequent phase uses — FileEntry, Category, Scope, ScanLocation, ScanResult, CleanupItem. Wire AppState into the app as the central MVVM state container.
Output: Complete model layer and AppState, ready for the file scanner in Phase 2.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@PROJECT.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

**Key requirements from PROJECT.md:**
- 9 categories with priority-based assignment (Agents, Debug, Memory, Project Config, Settings, Todos, Plans, Skills, Other)
- Scope: Global vs Project
- FileEntry needs: id (SHA256 truncated), name, path, displayName, category, scope, project, size, modifiedDate, isReadOnly
- ScanLocation: configurable scan paths
- CleanupItem: empty files, empty content, stale (30+ days)
- File ID = SHA256 of absolute path, truncated to first 8 bytes (16 hex chars)

**Architecture rules:**
- Swift 6 strict concurrency — models must be Sendable
- MVVM — AppState as @Observable or ObservableObject
- No force unwraps in production code
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core data models</name>
  <files>
    ClaudeShelf/Models/Category.swift,
    ClaudeShelf/Models/Scope.swift,
    ClaudeShelf/Models/FileEntry.swift,
    ClaudeShelf/Models/ScanLocation.swift,
    ClaudeShelf/Models/ScanResult.swift,
    ClaudeShelf/Models/CleanupItem.swift
  </files>
  <action>
    Create all data model types. All models must be Sendable (structs or enums are automatically Sendable). Use Swift 6 patterns.

    1. **Category.swift** — Enum with all 9 categories:
       ```
       enum Category: String, CaseIterable, Identifiable, Sendable, Codable {
           case agents, debug, memory, projectConfig, settings, todos, plans, skills, other
       }
       ```
       Add computed properties:
       - `displayName: String` — human-readable name (e.g., "Project Config")
       - `sfSymbol: String` — SF Symbol name for each category (e.g., "person.2" for agents, "ladybug" for debug, "brain" for memory, "doc.text" for projectConfig, "gearshape" for settings, "checklist" for todos, "map" for plans, "star" for skills, "folder" for other)
       - `priority: Int` — assignment priority (1=highest, used in scanner)
       - `id: String` — rawValue for Identifiable

    2. **Scope.swift** — Simple enum:
       ```
       enum Scope: String, Sendable, Codable {
           case global
           case project
       }
       ```

    3. **FileEntry.swift** — Primary file model:
       ```
       struct FileEntry: Identifiable, Hashable, Sendable {
           let id: String              // SHA256 truncated to 16 hex chars
           let name: String            // filename
           let path: String            // absolute path
           let displayName: String     // decoded name for display
           let category: Category
           let scope: Scope
           let project: String?        // decoded project name (nil for global)
           let size: Int64             // bytes
           let modifiedDate: Date
           let isReadOnly: Bool
       }
       ```
       Add a static helper `generateID(from path: String) -> String` that computes SHA256 of the path using CryptoKit and returns first 16 hex characters. Import CryptoKit (Apple framework, not third-party).

    4. **ScanLocation.swift** — Configurable scan location:
       ```
       struct ScanLocation: Identifiable, Hashable, Sendable, Codable {
           let id: UUID
           let path: String
           let isEnabled: Bool
           let isDefault: Bool  // true for built-in locations, false for user-added
       }
       ```
       Add a static property `defaultLocations: [ScanLocation]` returning the 8 default scan paths from PROJECT.md: ~/.claude/, ~/projects/, ~/src/, ~/dev/, ~/code/, ~/workspace/, ~/repos/, ~/

    5. **ScanResult.swift** — Complete scan output:
       ```
       struct ScanResult: Sendable {
           let files: [FileEntry]
           let scanDate: Date
           let duration: TimeInterval
           let errors: [String]        // non-fatal scan errors (e.g., permission denied)
       }
       ```

    6. **CleanupItem.swift** — Cleanup suggestion:
       ```
       enum CleanupReason: String, Sendable, Codable {
           case emptyFile          // 0 bytes
           case emptyContent       // contains only [], {}, null, or whitespace
           case stale              // not modified in 30+ days
       }

       struct CleanupItem: Identifiable, Sendable {
           let id: String          // same as FileEntry.id
           let file: FileEntry
           let reason: CleanupReason
           let detail: String      // human-readable reason
       }
       ```

    Add each new .swift file to the Xcode project's project.pbxproj (add to PBXBuildFile, PBXFileReference, PBXGroup, and PBXSourcesBuildPhase sections). Generate unique 24-character hex IDs for each pbxproj entry.

    Do NOT use `@Observable` macro on model structs — they are plain value types. `@Observable` is for the AppState class only.
  </action>
  <verify>
    Run: `xcodebuild -project ClaudeShelf.xcodeproj -scheme ClaudeShelf -configuration Debug build 2>&1 | tail -5`
    Should build successfully with no errors or warnings.
  </verify>
  <done>
    All 6 model files exist, compile without errors under Swift 6 strict concurrency, all types are Sendable, FileEntry.generateID works with CryptoKit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AppState and wire into app</name>
  <files>
    ClaudeShelf/App/AppState.swift,
    ClaudeShelf/App/ClaudeShelfApp.swift,
    ClaudeShelf/App/ContentView.swift
  </files>
  <action>
    1. **AppState.swift** — Central MVVM state container using @Observable (Swift 5.9+ Observation framework, available on macOS 14+):
       ```
       import SwiftUI

       @Observable
       @MainActor
       final class AppState {
           var files: [FileEntry] = []
           var selectedCategory: Category? = nil
           var selectedFile: FileEntry? = nil
           var searchText: String = ""
           var isScanning: Bool = false
           var scanLocations: [ScanLocation] = ScanLocation.defaultLocations
           var lastScanDate: Date? = nil
           var errorMessage: String? = nil

           // Computed: filtered files based on category and search
           var filteredFiles: [FileEntry] {
               var result = files
               if let category = selectedCategory {
                   result = result.filter { $0.category == category }
               }
               if !searchText.isEmpty {
                   let query = searchText.lowercased()
                   result = result.filter {
                       $0.name.lowercased().contains(query) ||
                       $0.displayName.lowercased().contains(query) ||
                       $0.path.lowercased().contains(query) ||
                       ($0.project?.lowercased().contains(query) ?? false)
                   }
               }
               return result
           }

           // Computed: file counts per category
           var categoryCounts: [Category: Int] {
               Dictionary(grouping: files, by: \.category).mapValues(\.count)
           }

           // Computed: total size per category
           var categorySizes: [Category: Int64] {
               Dictionary(grouping: files, by: \.category).mapValues { entries in
                   entries.reduce(0) { $0 + $1.size }
               }
           }
       }
       ```

    2. **Update ClaudeShelfApp.swift** — Inject AppState into environment:
       ```
       @main
       struct ClaudeShelfApp: App {
           @State private var appState = AppState()

           var body: some Scene {
               WindowGroup {
                   ContentView()
                       .environment(appState)
               }
           }
       }
       ```

    3. **Update ContentView.swift** — Accept AppState from environment and show basic structure:
       ```
       struct ContentView: View {
           @Environment(AppState.self) private var appState

           var body: some View {
               NavigationSplitView {
                   Text("Categories")
                       .navigationTitle("ClaudeShelf")
               } content: {
                   Text("\(appState.filteredFiles.count) files")
               } detail: {
                   Text("Select a file to edit")
                       .foregroundStyle(.secondary)
               }
               .frame(minWidth: 800, minHeight: 500)
           }
       }
       ```

    Add AppState.swift to project.pbxproj (PBXBuildFile, PBXFileReference, PBXGroup, PBXSourcesBuildPhase).

    Use @Observable (not ObservableObject) since we target macOS 15 which fully supports the Observation framework. Use @Environment (not @EnvironmentObject) to inject it.
  </action>
  <verify>
    Run: `xcodebuild -project ClaudeShelf.xcodeproj -scheme ClaudeShelf -configuration Debug build 2>&1 | tail -5`
    Should build successfully. Grep for warnings: `xcodebuild ... 2>&1 | grep -i warning | grep -v "Build system"` should show no concurrency warnings.
  </verify>
  <done>
    AppState exists with @Observable + @MainActor, injected via @Environment, ContentView reads from it, project builds clean with zero concurrency warnings under Swift 6 strict mode. Phase 1 complete.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodebuild -project ClaudeShelf.xcodeproj -scheme ClaudeShelf build` succeeds
- [ ] All 6 model files + AppState compile without warnings
- [ ] FileEntry.generateID produces consistent 16-char hex IDs
- [ ] AppState.filteredFiles correctly filters by category and search text
- [ ] No strict concurrency warnings
- [ ] All types are Sendable
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- 6 model files + AppState created and compiling
- Models are Sendable, AppState is @MainActor + @Observable
- ContentView reads from AppState via @Environment
- Phase 1 Foundation complete — ready for Phase 2 (File Scanner)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
