---
phase: 11-filewatcher-fsevents-rewrite
plan: 01
type: execute
domain: concurrency
---

<objective>
Replace per-directory DispatchSource file watching with FSEvents-based recursive watching so subdirectory changes are detected. Keep the same public API, debounce logic, and actor isolation.

Purpose: Fix audit finding H-3 — current FileWatcher misses changes in subdirectories because DispatchSource only watches individual directories, not their children.
Output: FileWatcher uses FSEvents for recursive watching, existing tests pass, new subdirectory test added.
</objective>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@ClaudeShelf/Services/FileWatcher.swift
@ClaudeShelf/App/AppState.swift
@ClaudeShelfTests/FileWatcherTests.swift

**Constraining decisions:**
- [08-01] Removed actor deinit — DispatchSource cancel handlers suffice. FSEvents must also handle cleanup without actor deinit.
- Actor isolation: FileWatcher is an actor. FSEvents callback is a C function pointer — must bridge to actor via context pointer.
- Swift 6 strict concurrency (`SWIFT_STRICT_CONCURRENCY=complete`)
</context>

<tasks>
<task type="auto">
  <name>Task 1: Rewrite FileWatcher with FSEvents recursive watching</name>
  <files>ClaudeShelf/Services/FileWatcher.swift</files>
  <action>
  Replace the entire DispatchSource-based implementation with FSEvents while keeping the same public API.

  **Public API (unchanged):**
  - `actor FileWatcher`
  - `init(debounceInterval: TimeInterval = 1.0)`
  - `func start(directories: [String], onChange: @escaping @Sendable () async -> Void)`
  - `func stop()`

  **FSEvents implementation:**

  1. Replace stored properties:
     - Remove `sources: [String: (source: DispatchSourceFileSystemObject, fd: Int32)]`
     - Add `private var streamRef: FSEventStreamRef?`
     - Keep `debounceTask`, `debounceInterval`, `onChange`

  2. Create `start(directories:onChange:)`:
     - Store onChange callback
     - Call `stopStream()` to clean up any existing stream
     - Convert directory strings to `[String] as CFArray`
     - Create a C callback function (must be a static/global function, NOT a closure):

     ```swift
     private static let eventCallback: FSEventStreamCallback = {
         (streamRef, clientCallBackInfo, numEvents, eventPaths, eventFlags, eventIds) in
         guard let info = clientCallBackInfo else { return }
         let watcher = Unmanaged<FileWatcherContext>.fromOpaque(info).takeUnretainedValue()
         watcher.notify()
     }
     ```

     - Since the FSEvents callback is a C function pointer that cannot capture `self` (an actor), use a helper class `FileWatcherContext` (NOT an actor — a plain class) to bridge:

     ```swift
     private final class FileWatcherContext: @unchecked Sendable {
         let onEvent: () -> Void
         init(onEvent: @escaping () -> Void) { self.onEvent = onEvent }
         func notify() { onEvent() }
     }
     ```

     - In `start()`, create the context that captures a reference to the actor's handleEvent:

     ```swift
     let context = FileWatcherContext {
         Task { await self.handleEvent() }
     }
     self.callbackContext = context
     ```

     - Store `callbackContext` as a property so it stays alive
     - Create FSEventStreamContext with `Unmanaged.passUnretained(context).toOpaque()` as info pointer
     - Use flags: `UInt32(kFSEventStreamCreateFlagUseCFTypes | kFSEventStreamCreateFlagFileEvents | kFSEventStreamCreateFlagNoDefer)`
     - Latency: 0.5 (FSEvents handles its own coalescing; we also debounce)
     - Create stream with `FSEventStreamCreate`
     - Schedule with `FSEventStreamSetDispatchQueue` on `DispatchQueue.global(qos: .utility)`
     - Start with `FSEventStreamStart`
     - Store the streamRef

  3. Create `stopStream()` private method:
     - If streamRef is non-nil: `FSEventStreamStop`, `FSEventStreamInvalidate`, `FSEventStreamRelease`
     - Set streamRef to nil
     - Set callbackContext to nil
     - Cancel debounceTask

  4. Update `stop()`:
     - Call `stopStream()`
     - Set onChange to nil

  5. Keep `handleEvent()`, `fireCallback()` unchanged — debounce logic is the same

  **Important:** Do NOT use `Unmanaged.passRetained` — it creates a retain cycle since the actor also holds the context. Use `passUnretained` and ensure the context stays alive via the `callbackContext` property.

  **Do NOT add a deinit** — Phase 8 decision: actor deinit is problematic. FSEvents stream will be stopped when `stop()` is called. If the actor is deallocated without stop(), the stream will be invalidated by the OS when the dispatch queue is released.
  </action>
  <verify>xcodegen generate && xcodebuild build -scheme ClaudeShelf -destination 'platform=macOS' 2>&1 | tail -5</verify>
  <done>FileWatcher compiles with FSEvents, no DispatchSource references remain, actor isolation maintained</done>
</task>

<task type="auto">
  <name>Task 2: Update tests and add recursive watching test</name>
  <files>ClaudeShelfTests/FileWatcherTests.swift</files>
  <action>
  Keep all 4 existing tests working (they test start/stop, skip nonexistent, file creation detection, debounce). Then add a new test for recursive subdirectory detection — the key behavior this rewrite enables.

  **New test: `testWatcherDetectsSubdirectoryFileCreation`**
  1. Create a subdirectory inside tempDir: `tempDir/subdir/`
  2. Start watcher on `[tempDir.path]` with debounceInterval 0.2
  3. Create a file inside the subdirectory: `tempDir/subdir/nested.txt`
  4. Assert the callback fires (this would FAIL with old DispatchSource implementation)
  5. Stop watcher

  **Existing tests should pass unchanged** — FSEvents detects the same events DispatchSource did, just also supports recursion.

  If the debounce test (`testDebounceCoalescesRapidEvents`) is flaky due to FSEvents timing differences, adjust the debounce interval or sleep durations slightly. FSEvents has its own coalescing so events may arrive differently than DispatchSource.
  </action>
  <verify>xcodebuild test -scheme ClaudeShelf -destination 'platform=macOS' -only-testing ClaudeShelfTests/FileWatcherTests 2>&1 | tail -20</verify>
  <done>All 5 FileWatcher tests pass (4 existing + 1 new recursive test), full test suite passes</done>
</task>
</tasks>

<verification>
Before declaring phase complete:
- [ ] `xcodegen generate && xcodebuild build` succeeds
- [ ] `xcodebuild test` — all tests pass (89+ tests, now 90 with new test)
- [ ] No DispatchSource references in FileWatcher.swift
- [ ] FSEventStream created with kFSEventStreamCreateFlagFileEvents for recursive watching
- [ ] Subdirectory file creation test passes
</verification>

<success_criteria>
- FileWatcher uses FSEvents instead of DispatchSource
- Recursive watching works (subdirectory changes detected)
- Same public API preserved (start/stop/debounce)
- Actor isolation maintained with Swift 6 strict concurrency
- All tests pass including new recursive test
</success_criteria>

<output>
After completion, create `.planning/phases/11-filewatcher-fsevents-rewrite/11-01-SUMMARY.md` with:
- Duration and task count
- FSEvents implementation details
- Test results including new recursive test
- Any deviations from plan
</output>
