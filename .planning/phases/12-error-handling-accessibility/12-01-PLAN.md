---
phase: 12-error-handling-accessibility
plan: 01
type: execute
domain: ui
---

<objective>
Fix silent trash failure in FileRowView, add VoiceOver accessibility labels to interactive elements, and handle stale FileEntry metadata by refreshing on file selection.

Purpose: Fix audit finding H-4 (silent trash failure), add accessibility for VoiceOver users (zero accessibility labels currently exist), and prevent showing stale file sizes/dates.
Output: User-visible trash error feedback, VoiceOver-ready interactive elements, fresh metadata on selection.
</objective>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@ClaudeShelf/Views/Sidebar/FileRowView.swift
@ClaudeShelf/Views/Sidebar/FileListView.swift
@ClaudeShelf/Views/Cleanup/CleanupSheet.swift
@ClaudeShelf/Views/Editor/FileDetailView.swift
@ClaudeShelf/App/ContentView.swift

**Constraining decisions:**
- [09-01] Error sanitization: user-friendly messages in UI, detailed errors via os_log
- [03-01] ContentUnavailableView for empty states
</context>

<tasks>
<task type="auto">
  <name>Task 1: Fix silent trash failure in FileRowView</name>
  <files>ClaudeShelf/Views/Sidebar/FileRowView.swift</files>
  <action>
  The current `trashFile()` method swallows errors silently — user gets no feedback when trash fails.

  1. Add state variable: `@State private var trashError: String?`
  2. Update `trashFile()` catch block:
     ```swift
     } catch {
         trashError = "Unable to move file to Trash. Please check permissions and try again."
         // Logger is not available in this file — add one if needed, or rely on FileOperations logging
     }
     ```
  3. Add `.alert()` modifier to the view (after the `.contextMenu`):
     ```swift
     .alert("Trash Error", isPresented: .init(
         get: { trashError != nil },
         set: { if !$0 { trashError = nil } }
     )) {
         Button("OK", role: .cancel) { trashError = nil }
     } message: {
         if let error = trashError { Text(error) }
     }
     ```

  This follows the same pattern already used in FileDetailView, FileListView, and ContentView for error alerts.
  </action>
  <verify>xcodegen generate && xcodebuild build -scheme ClaudeShelf -destination 'platform=macOS' 2>&1 | tail -5</verify>
  <done>FileRowView shows alert on trash failure, no silent error swallowing</done>
</task>

<task type="auto">
  <name>Task 2: Add VoiceOver accessibility labels to interactive elements</name>
  <files>ClaudeShelf/Views/Sidebar/FileRowView.swift, ClaudeShelf/Views/Cleanup/CleanupSheet.swift, ClaudeShelf/Views/Editor/FileDetailView.swift, ClaudeShelf/App/ContentView.swift, ClaudeShelf/Views/Sidebar/FileListView.swift</files>
  <action>
  Add `.accessibilityLabel()` and `.accessibilityHint()` to interactive elements that VoiceOver cannot describe. Currently zero accessibility labels exist.

  **FileRowView.swift:**
  - Checkbox image: `.accessibilityLabel(isSelected ? "Selected" : "Not selected")` and `.accessibilityAddTraits(.isButton)` and `.accessibilityHint("Double-tap to toggle selection")`
  - Category icon: `.accessibilityLabel(file.category.label)`
  - Lock icon: `.accessibilityLabel("Read-only")`
  - The overall row: `.accessibilityElement(children: .combine)` to merge child labels — or just label the key elements individually

  **CleanupSheet.swift — CleanupRow:**
  Read CleanupRow first (it may be in the same file or a separate Components file). Add:
  - Checkbox: `.accessibilityLabel(isSelected ? "Selected" : "Not selected")` and `.accessibilityAddTraits(.isButton)`
  - Row label: `.accessibilityLabel(item.file.displayName)` and `.accessibilityValue(item.detail)`

  **FileDetailView.swift:**
  - Lock icon (read-only indicator): `.accessibilityLabel("Read-only file")`
  - Dirty indicator (unsaved changes dot): `.accessibilityLabel("Unsaved changes")`
  - Save button: `.accessibilityLabel("Save file")` and `.accessibilityHint("Saves changes to disk")`

  **ContentView.swift:**
  - Rescan button: `.accessibilityLabel("Rescan files")`
  - Cleanup button: `.accessibilityLabel("Cleanup analysis")`
  - Export button: `.accessibilityLabel("Export files")`

  **FileListView.swift:**
  - Select/Done button: `.accessibilityLabel(appState.isBulkSelectionMode ? "Exit selection mode" : "Enter selection mode")`
  - Sort picker: `.accessibilityLabel("Sort order")`

  Keep labels concise. Only add to elements that are truly ambiguous — standard SwiftUI buttons with Text labels already get read by VoiceOver. Focus on Image-only buttons, icons, and custom tap targets.
  </action>
  <verify>xcodebuild build -scheme ClaudeShelf -destination 'platform=macOS' 2>&1 | tail -5</verify>
  <done>Interactive elements have VoiceOver labels, custom tap targets have button traits</done>
</task>

<task type="auto">
  <name>Task 3: Refresh FileEntry metadata on selection</name>
  <files>ClaudeShelf/App/AppState.swift</files>
  <action>
  When a file is selected, its metadata (size, modifiedDate, isReadOnly) may be stale if the file changed since the last scan. Refresh attributes from disk when `selectedFile` changes.

  1. Add a method to AppState:
     ```swift
     /// Refreshes a file entry's metadata from disk.
     private func refreshFileMetadata(for file: FileEntry) -> FileEntry {
         let fm = FileManager.default
         guard let attrs = try? fm.attributesOfItem(atPath: file.path) else { return file }
         let size = attrs[.size] as? Int64 ?? file.size
         let modDate = attrs[.modificationDate] as? Date ?? file.modifiedDate
         let isReadOnly = !fm.isWritableFile(atPath: file.path)
         guard size != file.size || modDate != file.modifiedDate || isReadOnly != file.isReadOnly else {
             return file
         }
         var updated = file
         updated.size = size
         updated.modifiedDate = modDate
         updated.isReadOnly = isReadOnly
         return updated
     }
     ```

  2. Check if FileEntry properties are mutable (var vs let). If they're let, check if FileEntry is a struct with let properties — if so, create a new FileEntry with updated values instead of mutating.

  3. When `selectedFile` is set, refresh and update in the files array:
     - Add a `didSet` observer on `selectedFile` or use a method that wraps selection
     - When a file is selected, call refreshFileMetadata and if changed, update the corresponding entry in `files` array

  **Important:** This is a lightweight stat() call — not a full rescan. Only refreshes the selected file, not all files.

  If FileEntry uses `let` properties, create a new FileEntry with the initializer instead of mutating. Check the FileEntry model to confirm.
  </action>
  <verify>xcodebuild test -scheme ClaudeShelf -destination 'platform=macOS' 2>&1 | grep -E '(Test Suite|Tests? (passed|failed)|BUILD)'</verify>
  <done>Selecting a file refreshes its size, date, and read-only status from disk</done>
</task>
</tasks>

<verification>
Before declaring phase complete:
- [ ] `xcodegen generate && xcodebuild build` succeeds
- [ ] `xcodebuild test` — all tests pass (90+ tests)
- [ ] FileRowView shows alert on trash failure
- [ ] VoiceOver labels on interactive elements (checkbox, icons, buttons)
- [ ] File selection refreshes metadata from disk
</verification>

<success_criteria>
- FileRowView trash errors shown to user via alert (H-4 fixed)
- VoiceOver accessibility labels on all interactive elements
- File metadata refreshed on selection
- All tests pass, no new warnings
</success_criteria>

<output>
After completion, create `.planning/phases/12-error-handling-accessibility/12-01-SUMMARY.md` with:
- Duration and task count
- Files modified
- Accessibility labels added
- Any deviations from plan
</output>
