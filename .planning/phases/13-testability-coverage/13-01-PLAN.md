---
phase: 13-testability-coverage
plan: 01
type: execute
domain: testing
---

<objective>
Extract protocol boundaries for DI, make ScanLocationStore injectable, and add SyntaxHighlighter + DiffView algorithm tests.

Purpose: Enable dependency injection for testing AppState in isolation, fix UserDefaults pollution in ScanLocationStoreTests, and add test coverage for two pure-function modules that currently have zero tests.
Output: Protocol types for services, injectable ScanLocationStore, ~20 new tests for SyntaxHighlighter and DiffView.
</objective>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@ClaudeShelf/Services/ScanLocationStore.swift
@ClaudeShelf/App/AppState.swift
@ClaudeShelf/App/ClaudeShelfApp.swift
@ClaudeShelf/Utilities/SyntaxHighlighter.swift
@ClaudeShelf/Views/Editor/DiffView.swift
@ClaudeShelfTests/ScanLocationStoreTests.swift

**Constraining decisions:**
- [01-01] XCTest (not Swift Testing)
- [01-02] @Observable, @Environment
- Swift 6 strict concurrency (`SWIFT_STRICT_CONCURRENCY=complete`)
- Zero external dependencies
</context>

<tasks>
<task type="auto">
  <name>Task 1: ScanLocationStore DI with injectable UserDefaults</name>
  <files>ClaudeShelf/Services/ScanLocationStore.swift, ClaudeShelf/App/AppState.swift, ClaudeShelf/App/ClaudeShelfApp.swift, ClaudeShelfTests/ScanLocationStoreTests.swift</files>
  <action>
  Currently ScanLocationStore is an enum with static methods that hardcode `UserDefaults.standard`. Refactor to support injectable storage.

  1. **Add a `ScanLocationStoring` protocol** at the top of ScanLocationStore.swift:
     ```swift
     /// Protocol for persistence of scan location configuration.
     protocol ScanLocationStoring: Sendable {
         func load(defaults: [ScanLocation]) -> [ScanLocation]
         func save(_ locations: [ScanLocation])
     }
     ```

  2. **Convert ScanLocationStore from enum to struct** conforming to `ScanLocationStoring`:
     ```swift
     struct ScanLocationStore: ScanLocationStoring {
         private let userDefaults: UserDefaults
         private let key = "scanLocations"
         private static let logger = Logger(subsystem: "com.claudeshelf.app", category: "ScanLocationStore")

         init(userDefaults: UserDefaults = .standard) {
             self.userDefaults = userDefaults
         }

         func load(defaults: [ScanLocation]) -> [ScanLocation] {
             // Same logic but use self.userDefaults instead of UserDefaults.standard
             ...
         }

         func save(_ locations: [ScanLocation]) {
             // Same logic but use self.userDefaults instead of UserDefaults.standard
             ...
         }
     }
     ```

     Keep `static` on the logger. The load/save logic stays exactly the same, just replace `UserDefaults.standard` with `self.userDefaults`.

  3. **Update AppState** to accept an injectable store:
     ```swift
     @Observable
     @MainActor
     final class AppState {
         // ... existing properties ...
         private let store: ScanLocationStoring

         init(store: ScanLocationStoring = ScanLocationStore()) {
             self.store = store
             self.scanLocations = store.load(defaults: ScanLocation.defaultLocations)
         }
     }
     ```
     - Update `saveScanLocations()` to use `store.save(scanLocations)` instead of `ScanLocationStore.save(scanLocations)`
     - ClaudeShelfApp.swift needs NO changes — `AppState()` still works with the default.

  4. **Update ScanLocationStoreTests** to use a dedicated UserDefaults suite:
     ```swift
     final class ScanLocationStoreTests: XCTestCase {
         private var suiteName: String!
         private var testDefaults: UserDefaults!
         private var store: ScanLocationStore!

         override func setUp() {
             super.setUp()
             suiteName = "com.claudeshelf.tests.\(UUID().uuidString)"
             testDefaults = UserDefaults(suiteName: suiteName)!
             store = ScanLocationStore(userDefaults: testDefaults)
         }

         override func tearDown() {
             UserDefaults.standard.removePersistentDomain(forName: suiteName)
             super.tearDown()
         }
     ```
     - Change all `ScanLocationStore.load(...)` → `store.load(...)`
     - Change all `ScanLocationStore.save(...)` → `store.save(...)`
     - Remove the line `UserDefaults.standard.removeObject(forKey: "scanLocations")` from tearDown
     - This eliminates UserDefaults pollution between tests entirely

  **Important:** The struct must be Sendable. `UserDefaults` is Sendable. The `key` String property is Sendable. Logger is `nonisolated(unsafe)` static. So the struct should be fine for Sendable conformance. If the compiler complains about Sendable, add `@unchecked Sendable` to the struct.
  </action>
  <verify>xcodegen generate && xcodebuild build -scheme ClaudeShelf -destination 'platform=macOS' 2>&1 | tail -5</verify>
  <done>ScanLocationStore injectable via protocol, UserDefaults no longer hardcoded, tests use isolated suite</done>
</task>

<task type="auto">
  <name>Task 2: Add SyntaxHighlighter tests</name>
  <files>ClaudeShelfTests/SyntaxHighlighterTests.swift</files>
  <action>
  SyntaxHighlighter is a pure enum with static methods — ideal for unit testing. Create a comprehensive test suite.

  Create `ClaudeShelfTests/SyntaxHighlighterTests.swift`:

  ```swift
  import XCTest
  @testable import ClaudeShelf

  final class SyntaxHighlighterTests: XCTestCase {

      // MARK: - File Type Detection

      func testDetectMarkdownExtension() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "CLAUDE.md"), .markdown)
      }

      func testDetectMarkdownFullExtension() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "README.markdown"), .markdown)
      }

      func testDetectJSON() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "settings.json"), .json)
      }

      func testDetectYAML() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "config.yaml"), .yaml)
      }

      func testDetectYML() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "config.yml"), .yaml)
      }

      func testDetectTOML() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "settings.toml"), .toml)
      }

      func testDetectPlainText() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "notes.txt"), .plainText)
      }

      func testDetectCaseInsensitive() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "FILE.JSON"), .json)
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: "README.MD"), .markdown)
      }

      func testDetectNoExtension() {
          XCTAssertEqual(SyntaxHighlighter.detectFileType(from: ".clauderc"), .plainText)
      }

      // MARK: - Highlight Returns Attributed String

      func testHighlightEmptyString() {
          let result = SyntaxHighlighter.highlight("", for: .json)
          XCTAssertEqual(result.length, 0)
      }

      func testHighlightPlainTextNoColoring() {
          let text = "Hello world"
          let result = SyntaxHighlighter.highlight(text, for: .plainText)
          XCTAssertEqual(result.string, text)
      }

      // MARK: - JSON Highlighting

      func testJSONKeysColored() {
          let json = #"{"name": "value"}"#
          let result = SyntaxHighlighter.highlight(json, for: .json)
          // Key "name": should have key color (purple)
          var range = NSRange()
          let attrs = result.attributes(at: 1, effectiveRange: &range) // inside "name"
          let color = attrs[.foregroundColor] as? NSColor
          XCTAssertNotNil(color)
          // The key pattern covers "name": so it should be purple (key color)
          XCTAssertEqual(color, NSColor.systemPurple)
      }

      func testJSONStringValuesColored() {
          let json = #"{"key": "hello"}"#
          let result = SyntaxHighlighter.highlight(json, for: .json)
          // Value "hello" at index 8-14 should be green (string) — but it's overridden by key pattern for "key"
          // Find the value string starting after ": "
          let valueStart = json.range(of: "\"hello\"")!
          let nsRange = NSRange(valueStart, in: json)
          var effectiveRange = NSRange()
          let attrs = result.attributes(at: nsRange.location + 1, effectiveRange: &effectiveRange)
          let color = attrs[.foregroundColor] as? NSColor
          // "hello" is a string value, should be green
          XCTAssertEqual(color, NSColor.systemGreen)
      }

      func testJSONBooleansColored() {
          let json = #"{"flag": true}"#
          let result = SyntaxHighlighter.highlight(json, for: .json)
          let trueRange = (json as NSString).range(of: "true")
          var effectiveRange = NSRange()
          let attrs = result.attributes(at: trueRange.location, effectiveRange: &effectiveRange)
          let color = attrs[.foregroundColor] as? NSColor
          XCTAssertEqual(color, NSColor.systemPink)
      }

      // MARK: - Markdown Highlighting

      func testMarkdownHeadingColored() {
          let md = "# Heading\nSome text"
          let result = SyntaxHighlighter.highlight(md, for: .markdown)
          var effectiveRange = NSRange()
          let attrs = result.attributes(at: 0, effectiveRange: &effectiveRange)
          let color = attrs[.foregroundColor] as? NSColor
          XCTAssertEqual(color, NSColor.systemBrown)
      }

      func testMarkdownCodeBlockColored() {
          let md = "```\ncode here\n```"
          let result = SyntaxHighlighter.highlight(md, for: .markdown)
          var effectiveRange = NSRange()
          let attrs = result.attributes(at: 4, effectiveRange: &effectiveRange)
          let color = attrs[.foregroundColor] as? NSColor
          XCTAssertEqual(color, NSColor.systemGreen)
      }

      // MARK: - YAML Highlighting

      func testYAMLKeyColored() {
          let yaml = "name: value"
          let result = SyntaxHighlighter.highlight(yaml, for: .yaml)
          var effectiveRange = NSRange()
          let attrs = result.attributes(at: 0, effectiveRange: &effectiveRange)
          let color = attrs[.foregroundColor] as? NSColor
          XCTAssertEqual(color, NSColor.systemPurple)
      }

      func testYAMLCommentColored() {
          let yaml = "key: value # comment"
          let result = SyntaxHighlighter.highlight(yaml, for: .yaml)
          let commentStart = (yaml as NSString).range(of: "#")
          var effectiveRange = NSRange()
          let attrs = result.attributes(at: commentStart.location, effectiveRange: &effectiveRange)
          let color = attrs[.foregroundColor] as? NSColor
          XCTAssertEqual(color, NSColor.systemGray)
      }

      // MARK: - TOML Highlighting

      func testTOMLSectionHeaderColored() {
          let toml = "[section]\nkey = \"value\""
          let result = SyntaxHighlighter.highlight(toml, for: .toml)
          var effectiveRange = NSRange()
          let attrs = result.attributes(at: 0, effectiveRange: &effectiveRange)
          let color = attrs[.foregroundColor] as? NSColor
          XCTAssertEqual(color, NSColor.systemPurple)
      }
  }
  ```

  The test approach:
  - File type detection: test each extension mapping
  - Highlighting: verify specific characters have expected foreground colors
  - Use `NSAttributedString.attributes(at:effectiveRange:)` to check colors
  - Test patterns: keys → purple, strings → green, booleans → pink, comments → gray, headings → brown

  **Important:** The SyntaxHighlighter.FileType enum must be Equatable for XCTAssertEqual. Check if it already is — enums with no associated values are auto-Equatable. If not, add `: Equatable` conformance.
  </action>
  <verify>xcodebuild test -scheme ClaudeShelf -destination 'platform=macOS' -only-testing ClaudeShelfTests/SyntaxHighlighterTests 2>&1 | tail -20</verify>
  <done>SyntaxHighlighter has comprehensive test coverage for file detection and all 4 format highlighters</done>
</task>

<task type="auto">
  <name>Task 3: Add DiffView algorithm tests and remove placeholder test</name>
  <files>ClaudeShelf/Views/Editor/DiffView.swift, ClaudeShelfTests/DiffViewTests.swift, ClaudeShelfTests/ClaudeShelfTests.swift</files>
  <action>
  The diff algorithm in DiffView.computeDiff is `private static`. To test it, make it `static` (internal access — visible to tests via `@testable import`).

  1. **In DiffView.swift**, change access on `computeDiff` and `DiffLine`:
     - Change `private enum DiffLine` to `enum DiffLine` (internal access for testability)
     - Change `private static func computeDiff` to `static func computeDiff`
     - Keep `private static func buildDiffOutput` as private — it's an implementation detail
     - The `DiffLine` enum needs to move from private to internal. It's currently at the top of the file before DiffView.

  2. **Create `ClaudeShelfTests/DiffViewTests.swift`**:
     ```swift
     import XCTest
     @testable import ClaudeShelf

     final class DiffViewTests: XCTestCase {

         // MARK: - No Changes

         func testNoDifference() {
             let text = "line one\nline two"
             let result = DiffView.computeDiff(original: text, modified: text)
             XCTAssertEqual(result.count, 2)
             for line in result {
                 if case .unchanged = line { } else {
                     XCTFail("Expected all lines unchanged")
                 }
             }
         }

         // MARK: - Additions

         func testSingleLineAdded() {
             let original = "line one\nline two"
             let modified = "line one\ninserted\nline two"
             let result = DiffView.computeDiff(original: original, modified: modified)
             let addedLines = result.filter { if case .added = $0 { return true }; return false }
             XCTAssertEqual(addedLines.count, 1)
             XCTAssertEqual(addedLines.first?.text, "inserted")
         }

         // MARK: - Removals

         func testSingleLineRemoved() {
             let original = "line one\nline two\nline three"
             let modified = "line one\nline three"
             let result = DiffView.computeDiff(original: original, modified: modified)
             let removedLines = result.filter { if case .removed = $0 { return true }; return false }
             XCTAssertEqual(removedLines.count, 1)
             XCTAssertEqual(removedLines.first?.text, "line two")
         }

         // MARK: - Mixed Changes

         func testAddAndRemove() {
             let original = "aaa\nbbb\nccc"
             let modified = "aaa\nxxx\nccc"
             let result = DiffView.computeDiff(original: original, modified: modified)
             let removed = result.filter { if case .removed = $0 { return true }; return false }
             let added = result.filter { if case .added = $0 { return true }; return false }
             XCTAssertEqual(removed.count, 1)
             XCTAssertEqual(removed.first?.text, "bbb")
             XCTAssertEqual(added.count, 1)
             XCTAssertEqual(added.first?.text, "xxx")
         }

         // MARK: - Edge Cases

         func testEmptyOriginal() {
             let result = DiffView.computeDiff(original: "", modified: "new line")
             let added = result.filter { if case .added = $0 { return true }; return false }
             XCTAssertGreaterThanOrEqual(added.count, 1)
         }

         func testEmptyModified() {
             let result = DiffView.computeDiff(original: "old line", modified: "")
             let removed = result.filter { if case .removed = $0 { return true }; return false }
             XCTAssertGreaterThanOrEqual(removed.count, 1)
         }

         func testBothEmpty() {
             let result = DiffView.computeDiff(original: "", modified: "")
             // Single empty line, unchanged
             XCTAssertEqual(result.count, 1)
         }

         func testAllLinesChanged() {
             let original = "aaa\nbbb"
             let modified = "xxx\nyyy"
             let result = DiffView.computeDiff(original: original, modified: modified)
             let removed = result.filter { if case .removed = $0 { return true }; return false }
             let added = result.filter { if case .added = $0 { return true }; return false }
             XCTAssertEqual(removed.count, 2)
             XCTAssertEqual(added.count, 2)
         }

         // MARK: - DiffLine Properties

         func testDiffLinePrefix() {
             let lines = DiffView.computeDiff(original: "old", modified: "new")
             for line in lines {
                 switch line {
                 case .unchanged:
                     XCTAssertEqual(line.prefix, " ")
                 case .added:
                     XCTAssertEqual(line.prefix, "+")
                 case .removed:
                     XCTAssertEqual(line.prefix, "\u{2212}")
                 }
             }
         }
     }
     ```

  3. **Delete** `ClaudeShelfTests/ClaudeShelfTests.swift` — it's a placeholder with a single `testExample` that does nothing.

  4. **Update project.yml** if needed — check that new test files are auto-discovered (XcodeGen uses directory-based sources, so new files should be picked up automatically).
  </action>
  <verify>xcodebuild test -scheme ClaudeShelf -destination 'platform=macOS' -only-testing ClaudeShelfTests/DiffViewTests 2>&1 | tail -20</verify>
  <done>DiffView algorithm testable with internal access, 9 tests covering all diff scenarios, placeholder test removed</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodegen generate && xcodebuild build` succeeds
- [ ] `xcodebuild test` — all tests pass (90 existing + ~30 new)
- [ ] ScanLocationStore is injectable via protocol
- [ ] AppState accepts DI parameters with production defaults
- [ ] ScanLocationStoreTests use isolated UserDefaults suite
- [ ] SyntaxHighlighter has file detection + highlighting tests
- [ ] DiffView algorithm is testable and tested
- [ ] Placeholder test removed
</verification>

<success_criteria>
- ScanLocationStoring protocol exists, ScanLocationStore conforms
- AppState init accepts store parameter with default
- ScanLocationStoreTests no longer pollute UserDefaults.standard
- SyntaxHighlighter has ~20 tests covering all file types and highlighting
- DiffView.computeDiff testable, 9+ diff algorithm tests
- Placeholder ClaudeShelfTests.swift deleted
- All tests pass, no new warnings
</success_criteria>

<output>
After completion, create `.planning/phases/13-testability-coverage/13-01-SUMMARY.md` with:
- Duration and task count
- Files created/modified
- Protocol boundaries added
- Test count increase
- Any deviations from plan
</output>
