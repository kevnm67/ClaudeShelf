---
phase: 13-testability-coverage
plan: 02
type: execute
domain: testing
---

<objective>
Add FileScanner and AppState test suites using DI infrastructure from Plan 01.

Purpose: Cover the two largest untested modules — FileScanner (directory walking, depth limits, skip rules) and AppState (scan location management, filtering, bulk selection).
Output: ~25 new tests across FileScannerTests and AppStateTests.
</objective>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@ClaudeShelf/Services/FileScanner.swift
@ClaudeShelf/App/AppState.swift
@ClaudeShelf/Services/ScanLocationStore.swift (after Plan 01 refactoring)
@ClaudeShelfTests/FileWatcherTests.swift (temp dir pattern reference)
@ClaudeShelfTests/FileOperationsTests.swift (temp dir pattern reference)

**Constraining decisions:**
- [01-01] XCTest (not Swift Testing)
- [13-01] ScanLocationStoring protocol + injectable AppState
- Temp directory pattern from FileOperationsTests for filesystem tests
- Actor testing pattern from FileWatcherTests for async actor methods
</context>

<tasks>
<task type="auto">
  <name>Task 1: Add FileScanner tests</name>
  <files>ClaudeShelfTests/FileScannerTests.swift</files>
  <action>
  FileScanner is an actor with complex recursive logic. Test it by creating real temp directory structures.

  Create `ClaudeShelfTests/FileScannerTests.swift`:

  ```swift
  import XCTest
  @testable import ClaudeShelf

  final class FileScannerTests: XCTestCase {
      private var tempDir: URL!
      private var scanner: FileScanner!

      override func setUp() {
          super.setUp()
          tempDir = FileManager.default.temporaryDirectory
              .appendingPathComponent("FileScannerTests-\(UUID().uuidString)")
          try? FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
          scanner = FileScanner()
      }

      override func tearDown() {
          try? FileManager.default.removeItem(at: tempDir)
          super.tearDown()
      }

      // Helper to create file
      private func createFile(_ relativePath: String, content: String = "test") {
          let fileURL = tempDir.appendingPathComponent(relativePath)
          let dir = fileURL.deletingLastPathComponent()
          try? FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
          try? content.write(to: fileURL, atomically: true, encoding: .utf8)
      }

      private func scanLocation() -> ScanLocation {
          ScanLocation(id: UUID(), path: tempDir.path, isEnabled: true, isDefault: false)
      }
  ```

  **Test cases to implement:**

  1. **testDiscoversCLAUDEMDAtRoot** — Create `CLAUDE.md` at tempDir root. Scan. Assert 1 file found with name "CLAUDE.md".

  2. **testDiscoversClaudercAtRoot** — Create `.clauderc` at tempDir root. Scan. Assert 1 file found.

  3. **testIgnoresNonSpecialFilesOutsideClaude** — Create `random.txt` at root. Scan. Assert 0 files found.

  4. **testDiscoversFilesInsideClaudeDir** — Create `.claude/settings.json` and `.claude/commands/test.md`. Scan. Assert 2 files found.

  5. **testFiltersExtensionsInsideClaude** — Create `.claude/image.png` (not a known extension). Scan. Assert 0 files found.

  6. **testDepthLimitOutsideClaude** — Create:
     - `level1/CLAUDE.md` (depth 1 — within limit)
     - `level1/level2/CLAUDE.md` (depth 2 — within limit)
     - `level1/level2/level3/CLAUDE.md` (depth 3 — beyond limit)
     Scan. Assert 2 files found (not the depth-3 one).

  7. **testNoDepthLimitInsideClaude** — Create `.claude/deep/nested/sub/settings.json`. Scan. Assert 1 file found.

  8. **testSkipsGitDirectory** — Create `.git/config.json`, `.claude/settings.json`. Scan. Assert 1 file found (only .claude one).

  9. **testSkipsNodeModules** — Create `node_modules/CLAUDE.md`. Scan. Assert 0 files found.

  10. **testSkipsHiddenDirectoriesExceptClaude** — Create `.hidden/CLAUDE.md`, `.claude/settings.md`. Scan. Assert 1 file found (only .claude one).

  11. **testDisabledLocationSkipped** — Create `CLAUDE.md`. Create a disabled ScanLocation. Scan. Assert 0 files found.

  12. **testNonexistentLocationDoesNotError** — Create a ScanLocation with path "/nonexistent/path". Scan. Assert 0 files returned, 0 errors (it silently skips).

  13. **testScanReturnsFileEntries** — Use `scan(locations:)` instead of `scanLocations()`. Create `.claude/settings.json`. Assert result has FileEntry with correct category, scope, name.

  Each test uses the `await scanner.scanLocations([scanLocation()])` pattern (async actor call).
  For test 13, use `await scanner.scan(locations: [scanLocation()])`.

  **Important:** All paths use the temp directory — no personal paths. The scanner resolves `~` via `expandingTildeInPath` but our test locations use absolute paths already.
  </action>
  <verify>xcodebuild test -scheme ClaudeShelf -destination 'platform=macOS' -only-testing ClaudeShelfTests/FileScannerTests 2>&1 | tail -20</verify>
  <done>FileScanner has 13 tests covering depth limits, skip rules, .claude handling, special files, and disabled locations</done>
</task>

<task type="auto">
  <name>Task 2: Add AppState tests with mock dependencies</name>
  <files>ClaudeShelfTests/AppStateTests.swift</files>
  <action>
  AppState is `@Observable @MainActor` and after Plan 01 accepts an injectable `ScanLocationStoring`. Create tests using an in-memory store mock.

  Create `ClaudeShelfTests/AppStateTests.swift`:

  ```swift
  import XCTest
  @testable import ClaudeShelf

  /// In-memory implementation of ScanLocationStoring for testing.
  private final class MockScanLocationStore: ScanLocationStoring {
      private var stored: [ScanLocation]?

      func load(defaults: [ScanLocation]) -> [ScanLocation] {
          stored ?? defaults
      }

      func save(_ locations: [ScanLocation]) {
          stored = locations
      }
  }

  @MainActor
  final class AppStateTests: XCTestCase {
      private var store: MockScanLocationStore!
      private var appState: AppState!

      override func setUp() {
          super.setUp()
          store = MockScanLocationStore()
          appState = AppState(store: store)
      }
  ```

  **Test cases to implement:**

  1. **testInitLoadsDefaultScanLocations** — Create AppState with mock store. Assert scanLocations equals ScanLocation.defaultLocations.

  2. **testAddScanLocationAppendsAndSaves** — Add a custom path. Assert scanLocations.count increased by 1. Assert the store received a save call (check store.stored != nil).

  3. **testAddDuplicateScanLocationIgnored** — Add same path twice. Assert count increased by only 1.

  4. **testRemoveScanLocationOnlyCustom** — Add a custom location, get its ID, remove it. Assert count is back to defaults only.

  5. **testRemoveDefaultLocationIgnored** — Try to remove a default location. Assert count unchanged.

  6. **testToggleScanLocationFlipsEnabled** — Get first location, check its enabled state, toggle, check flipped.

  7. **testFilteredFilesByCategory** — Set `appState.files` to test data with mixed categories. Set `selectedCategory`. Assert `filteredFiles` only contains matching category.

  8. **testFilteredFilesBySearchText** — Set `appState.files` to test data. Set `searchText = "claude"`. Assert filtered results match.

  9. **testCategoryCountsComputed** — Set files with known categories. Assert `categoryCounts` matches expected dictionary.

  10. **testBulkSelectionToggle** — Toggle a file ID. Assert it's in `selectedFileIDs`. Toggle again. Assert removed.

  11. **testSelectAllFiltered** — Set files, call `selectAllFiltered()`. Assert all file IDs selected.

  12. **testClearSelectionResetsMode** — Enter bulk mode, select files, call `clearSelection()`. Assert empty and mode off.

  13. **testRemoveFilesClearsFromSelection** — Set files, select some, remove them. Assert they're gone from both `files` and `selectedFileIDs`.

  Helper to create test FileEntry objects:
  ```swift
  private func makeEntry(
      name: String = "test.md",
      path: String = "/tmp/test.md",
      category: Category = .instructions,
      scope: Scope = .global
  ) -> FileEntry {
      FileEntry(
          id: FileEntry.generateID(from: path),
          name: name,
          path: path,
          displayName: name,
          category: category,
          scope: scope,
          project: nil,
          size: 100,
          modifiedDate: Date(),
          isReadOnly: false
      )
  }
  ```

  **Important:** Tests must be `@MainActor` since AppState is `@MainActor`. The test class gets `@MainActor` annotation. Do NOT test `performScan()` or file watching — those require real filesystem and are covered by FileScannerTests. Focus on pure state management logic.
  </action>
  <verify>xcodebuild test -scheme ClaudeShelf -destination 'platform=macOS' -only-testing ClaudeShelfTests/AppStateTests 2>&1 | tail -20</verify>
  <done>AppState has 13 tests covering scan location management, filtering, bulk selection, and state cleanup</done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodegen generate && xcodebuild build` succeeds
- [ ] `xcodebuild test` — all tests pass (previous count + ~25 new)
- [ ] FileScannerTests cover depth limits, skip rules, .claude handling
- [ ] AppStateTests cover state management without filesystem dependency
- [ ] No UserDefaults pollution in any test
</verification>

<success_criteria>
- FileScanner has 13 tests covering all major scanning behaviors
- AppState has 13 tests covering state management
- All tests pass with zero UserDefaults pollution
- No new warnings
</success_criteria>

<output>
After completion, create `.planning/phases/13-testability-coverage/13-02-SUMMARY.md` with:
- Duration and task count
- Files created
- Test count increase
- Coverage improvements
- Any deviations from plan
</output>
