---
phase: 04-editor
plan: 01
type: execute
---

<objective>
Create an NSTextView-based code editor wrapped in NSViewRepresentable with line numbers, replacing the read-only Text display.

Purpose: SwiftUI's TextEditor lacks line numbers, syntax highlighting hooks, and fine-grained undo control. NSTextView via NSViewRepresentable is the standard macOS pattern for code editors and gives us all these capabilities.
Output: CodeEditorView (NSViewRepresentable) with editable monospaced text, line number gutter, and integration into the detail column replacing the static Text viewer.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Auto-selected based on dependency graph:
@.planning/phases/03-core-ui/03-03-SUMMARY.md

# Key source files:
@ClaudeShelf/App/AppState.swift
@ClaudeShelf/App/ContentView.swift
@ClaudeShelf/Views/Editor/FileDetailView.swift
@ClaudeShelf/Models/FileEntry.swift

**Tech stack available:** SwiftUI, Swift 6, AppKit (NSTextView, NSScrollView, NSRulerView), Observation framework
**Established patterns:** @Observable + @MainActor, @Environment, NSViewRepresentable for AppKit bridging, .task(id:) for async loading
**Constraining decisions:**
- [01-02]: @Observable + @Environment pattern
- [03-03]: FileDetailView has metadata header + .task(id:) content loading
- CLAUDE.md: No external dependencies — Apple frameworks only
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CodeEditorView NSViewRepresentable</name>
  <files>ClaudeShelf/Views/Editor/CodeEditorView.swift, ClaudeShelf.xcodeproj/project.pbxproj</files>
  <action>
Create CodeEditorView.swift in Views/Editor/. This wraps NSTextView in NSViewRepresentable:

1. **CodeEditorView struct** (NSViewRepresentable):
   - Properties: @Binding var text: String, var isEditable: Bool = true, var onTextChange: ((String) -> Void)? = nil
   - makeNSView: Create NSScrollView containing NSTextView
     - NSScrollView: hasVerticalScroller = true, hasHorizontalScroller = true
     - NSTextView: isEditable (from property), font = .monospacedSystemFont(ofSize: 13, weight: .regular), allowsUndo = true, isAutomaticQuoteSubstitutionEnabled = false, isAutomaticDashSubstitutionEnabled = false, isAutomaticTextReplacementEnabled = false, isAutomaticSpellingCorrectionEnabled = false
     - textContainerInset = NSSize(width: 8, height: 8)
     - Set autoresizingMask on textView to [.width] for horizontal expansion. Set textContainer?.widthTracksTextView = false and textContainer?.containerSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude) for horizontal scrolling
   - updateNSView: Only update text if the NSTextView's string differs from the binding (to avoid cursor jumps)
   - Set NSTextView.isEditable based on isEditable property

2. **Coordinator** (NSObject, NSTextViewDelegate):
   - Hold reference to parent
   - textDidChange(_:) — read textView.string, call parent.onTextChange?(text) and update parent.text binding
   - Use a flag `isUpdating` to prevent feedback loops between updateNSView and textDidChange

3. **Line numbers** via NSRulerView:
   - Enable the ruler: scrollView.rulersVisible = true, scrollView.hasVerticalRuler = true
   - Create a custom LineNumberRulerView (subclass of NSRulerView) — define as a private class within the file
   - LineNumberRulerView:
     - Override requiredThickness: calculate based on digit count of total lines
     - Override drawHashMarksAndLabels(in:): iterate visible lines using NSLayoutManager.enumerateLineFragments, draw line numbers right-aligned in the gutter
     - Use NSLayoutManager.glyphRange(forBoundingRect:in:) to find visible range, then enumerate line fragments
     - Font: .monospacedDigitSystemFont(ofSize: 11, weight: .regular), color: .secondaryLabelColor
   - Register for NSText.didChangeNotification on the textView to call setNeedsDisplay on the ruler when text changes
   - Ruler width: max(40, calculated width based on line count)

4. Include #Preview with sample text

**IMPORTANT for Swift 6 strict concurrency:**
- NSViewRepresentable methods run on MainActor already
- The Coordinator needs @MainActor or @preconcurrency to avoid Sendable warnings
- Mark Coordinator as @MainActor since it only interacts with UI

Add to project.pbxproj with F1 prefix IDs (Phase 4 plan 1). Add to Editor group.
  </action>
  <verify>xcodebuild build -project ClaudeShelf.xcodeproj -scheme ClaudeShelf -destination 'platform=macOS' 2>&1 | tail -5</verify>
  <done>CodeEditorView.swift exists, builds without errors, NSTextView displays editable monospaced text with line numbers in gutter</done>
</task>

<task type="auto">
  <name>Task 2: Integrate CodeEditorView into FileDetailView</name>
  <files>ClaudeShelf/Views/Editor/FileDetailView.swift</files>
  <action>
Replace the read-only Text content in FileDetailView with CodeEditorView:

1. Replace the ScrollView+Text content display with CodeEditorView:
   - Change @State var fileContent: String? to @State var fileContent: String = ""
   - Change @State var loadError: String? stays
   - Add @State var originalContent: String = "" (stores the on-disk version for later diff in 04-03)
   - Add @State var isLoaded: Bool = false to track loading state
   - In .task(id:): set isLoaded = false, load content, set both fileContent and originalContent to loaded text, set isLoaded = true
   - In contentView: if isLoaded, show CodeEditorView(text: $fileContent, isEditable: !file.isReadOnly)
   - If loadError, show the error ContentUnavailableView
   - If !isLoaded, show ProgressView

2. Keep the metadata header exactly as-is (no changes to headerView)

3. Update #Preview

The CodeEditorView takes a @Binding so FileDetailView now holds the mutable text state. This sets up for Cmd+S save in 04-03 (compare fileContent to originalContent for dirty detection).
  </action>
  <verify>xcodebuild build -project ClaudeShelf.xcodeproj -scheme ClaudeShelf -destination 'platform=macOS' 2>&1 | tail -5</verify>
  <done>FileDetailView uses CodeEditorView for content display, editable for writable files, read-only for isReadOnly files, line numbers visible</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `xcodebuild build` succeeds without errors
- [ ] CodeEditorView.swift exists in Views/Editor/
- [ ] NSTextView displays monospaced text with horizontal and vertical scrolling
- [ ] Line number gutter shows correct line numbers
- [ ] FileDetailView uses CodeEditorView instead of Text
- [ ] Read-only files show non-editable text view
- [ ] All 40 existing tests pass
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No build errors or warnings introduced
- CodeEditorView provides editable NSTextView with line numbers
- FileDetailView integrates the editor with metadata header preserved
</success_criteria>

<output>
After completion, create `.planning/phases/04-editor/04-01-SUMMARY.md`
</output>
